{"ast":null,"code":"import _objectSpread from\"/Users/angelajiang/vex-auton-tool2/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{useState,useRef}from\"react\";import\"./App.css\";import{generateEZTemplateAuton}from\"./components/ezlogic.js\";import Field from\"./components/field.js\";import Inputs from\"./components/inputs.js\";import CodeOutput from\"./components/codeoutput.js\";import Subsystems from\"./components/subsystems.js\";//helper for \"actions\" object\nimport{jsx as _jsx,jsxs as _jsxs}from\"react/jsx-runtime\";const defaultActions=()=>({intake:false,outtake:false,stopIntake:false,descore:false,wait:0,pneumatics:null,// \"high\" | \"low\" | null\nhoardMotors:false,ramDescore:false,slew:null// number | null\n});function App(){const[rotation,setRotation]=useState(0);// 0 for no rotation, 90 for blue alliance, 270 for red alliance\nconst[points,setPoints]=useState([]);// array of points with {x, y, rawX, rawY, heading, direction}\nconst[offsets,setOffsets]=useState({//distances from rotational center to robot edges, makes placeholder rectangle\nleft:\"\",right:\"\",back:\"\",front:\"\"});const[currentHeading,setCurrentHeading]=useState(0);// array for point headings\nconst[currentDirection,setCurrentDirection]=useState(1);// \"fwd\" or \"rev\" for forward or reverse direction\nconst[selectedPointIndex,setSelectedPointIndex]=useState(null);//refs to track dragging state\nconst draggingPointIndex=useRef(null);const isDragging=useRef(false);//currently dragging a point\nconst wasDragging=useRef(false);//when wasDragging is true, it means a user was dragging a point, so the next click should not add a point\n//constants for field size and scale\nconst fieldSizeInches=144;const fieldImagePixels=600;const scale=fieldSizeInches/fieldImagePixels;//used to prevent double clicks from adding points instead of deleting\nconst clickTimeout=useRef(null);// updates offsets on input change\nconst handleOffsetChange=e=>{const{name,value}=e.target;//gets label (left, right, back, front) and value from input\nsetOffsets(prev=>_objectSpread(_objectSpread({},prev),{},{//copies previous offsets\n[name]:value===\"\"?\"\":parseFloat(value)//the name becomes the key\n//if the input is empty, set to empty string\n//otherwise parse the value to a float\n}));};//if the user clicks on a point, start dragging it\n//handleMouseDown = click on an already existing point\nconst handleMouseDown=index=>{draggingPointIndex.current=index;//index = index of point clicked from points array\nisDragging.current=true;wasDragging.current=false;};//when user moves a point\nconst handleMouseMove=e=>{if(!isDragging.current||draggingPointIndex.current===null)return;//if not currently dragging or no point has been dragged, ignore\nwasDragging.current=true;//else set wasDragging to true so next click does not add a point\nconst container=e.currentTarget;//e.currentTarget is the point currently being dragged\nconst rect=container.getBoundingClientRect();//info about the container's pos and size\nlet rawX=e.clientX-rect.left;//how far the mouse is from the left edge of the image\nlet rawY=e.clientY-rect.top;//how far the mouse is from the top edge of the image\n//clamp rawX and rawY to be within the image bounds\nrawX=Math.max(0,Math.min(rawX,rect.width));rawY=Math.max(0,Math.min(rawY,rect.height));//sets center of the field as (0, 0), converts from pixels to inches\nconst dx=(rawX-rect.width/2)*scale;const dy=(rawY-rect.height/2)*scale;//checks that robot placeholder is fully inside field\nconst robotLeft=dx-offsets.left;const robotRight=dx+offsets.right;const robotBack=-dy-offsets.back;const robotFront=-dy+offsets.front;if(robotLeft<-72||robotRight>72||robotBack<-72||robotFront>72){//if its outside, ignore\nreturn;}const updated=[...points];//create a copy of points array to update\nupdated[draggingPointIndex.current]=_objectSpread(_objectSpread({},updated[draggingPointIndex.current]),{},{//store existing properties\nx:dx,//also stores coordinates in inches\ny:-dy,//negative y because dy is distance from top, so it becomes more positive as you go down\n//used for labeling on ui\nrawX,//raw coords for displaying on field\nrawY});setPoints(updated);};// Mouse up - finish dragging\nconst handleMouseUp=()=>{draggingPointIndex.current=null;setTimeout(()=>{isDragging.current=false;wasDragging.current=false;},10);};// Double click to delete point\nconst handleDoubleClick=index=>{if(clickTimeout.current){clearTimeout(clickTimeout.current);clickTimeout.current=null;}setPoints(points.filter((_,i)=>i!==index));};// Click on empty field to add a point (only if not dragging)\nconst handleClick=e=>{if(wasDragging.current)return;if(clickTimeout.current)return;const rect=e.currentTarget.getBoundingClientRect();const rawX=e.clientX-rect.left;const rawY=e.clientY-rect.top;clickTimeout.current=setTimeout(()=>{clickTimeout.current=null;// Out of bounds, ignore\nif(rawX<0||rawY<0||rawX>rect.width||rawY>rect.height)return;const dx=(rawX-rect.width/2)*scale;const dy=(rawY-rect.height/2)*scale;// Check robot bounds with offsets\nconst robotLeft=dx-offsets.left;const robotRight=dx+offsets.right;const robotBack=-dy-offsets.back;const robotFront=-dy+offsets.front;if(robotLeft<-72||robotRight>72||robotBack<-72||robotFront>72)return;setPoints([...points,{x:dx,y:-dy,rawX,rawY,heading:currentHeading,direction:currentDirection}]);},200);};// Heading input change\nconst handleHeadingChange=e=>{const newHeading=parseFloat(e.target.value)||0;setCurrentHeading(newHeading);if(points.length>0){const updated=[...points];updated[points.length-1]=_objectSpread(_objectSpread({},updated[points.length-1]),{},{heading:newHeading});setPoints(updated);}};// Direction input change\nconst handleDirectionChange=e=>{const newDirection=e.target.value;// string \"fwd\" or \"rev\"\nsetCurrentDirection(newDirection);if(points.length>0){const updated=[...points];updated[points.length-1]=_objectSpread(_objectSpread({},updated[points.length-1]),{},{direction:newDirection});setPoints(updated);}};return/*#__PURE__*/_jsxs(\"div\",{className:\"App\",style:{userSelect:\"none\"},children:[/*#__PURE__*/_jsx(\"h1\",{children:\"vex auton tool\"}),/*#__PURE__*/_jsx(Inputs,{rotation:rotation,setRotation:setRotation,setPoints:setPoints,offsets:offsets,handleOffsetChange:handleOffsetChange,currentHeading:currentHeading,handleHeadingChange:handleHeadingChange,currentDirection:currentDirection,handleDirectionChange:handleDirectionChange}),/*#__PURE__*/_jsxs(\"div\",{style:{display:\"flex\",alignItems:\"flex-start\",gap:\"20px\",maxWidth:\"1100px\",margin:\"20px\"},children:[/*#__PURE__*/_jsx(Field,{points:points,setPoints:setPoints,offsets:offsets,rotation:rotation,fieldImagePixels:fieldImagePixels,scale:scale,handleClick:handleClick,handleMouseDown:handleMouseDown,handleDoubleClick:handleDoubleClick,handleMouseMove:handleMouseMove,handleMouseUp:handleMouseUp}),/*#__PURE__*/_jsx(Subsystems,{}),/*#__PURE__*/_jsx(CodeOutput,{code:generateEZTemplateAuton(points)})]})]});}export default App;","map":{"version":3,"names":["React","useState","useRef","generateEZTemplateAuton","Field","Inputs","CodeOutput","Subsystems","jsx","_jsx","jsxs","_jsxs","defaultActions","intake","outtake","stopIntake","descore","wait","pneumatics","hoardMotors","ramDescore","slew","App","rotation","setRotation","points","setPoints","offsets","setOffsets","left","right","back","front","currentHeading","setCurrentHeading","currentDirection","setCurrentDirection","selectedPointIndex","setSelectedPointIndex","draggingPointIndex","isDragging","wasDragging","fieldSizeInches","fieldImagePixels","scale","clickTimeout","handleOffsetChange","e","name","value","target","prev","_objectSpread","parseFloat","handleMouseDown","index","current","handleMouseMove","container","currentTarget","rect","getBoundingClientRect","rawX","clientX","rawY","clientY","top","Math","max","min","width","height","dx","dy","robotLeft","robotRight","robotBack","robotFront","updated","x","y","handleMouseUp","setTimeout","handleDoubleClick","clearTimeout","filter","_","i","handleClick","heading","direction","handleHeadingChange","newHeading","length","handleDirectionChange","newDirection","className","style","userSelect","children","display","alignItems","gap","maxWidth","margin","code"],"sources":["/Users/angelajiang/vex-auton-tool2/src/App.js"],"sourcesContent":["import React, { useState, useRef } from \"react\";\nimport \"./App.css\";\nimport { generateEZTemplateAuton } from \"./components/ezlogic.js\";\nimport Field from \"./components/field.js\";\nimport Inputs from \"./components/inputs.js\";\nimport CodeOutput from \"./components/codeoutput.js\";\nimport Subsystems from \"./components/subsystems.js\";\n\n//helper for \"actions\" object\nconst defaultActions = () => ({\n  intake: false,\n  outtake: false,\n  stopIntake: false,\n  descore: false,\n  wait: 0,\n  pneumatics: null, // \"high\" | \"low\" | null\n  hoardMotors: false,\n  ramDescore: false,\n  slew: null, // number | null\n});\n\nfunction App() {\n  const [rotation, setRotation] = useState(0); // 0 for no rotation, 90 for blue alliance, 270 for red alliance\n  const [points, setPoints] = useState([]); // array of points with {x, y, rawX, rawY, heading, direction}\n  const [offsets, setOffsets] = useState({\n    //distances from rotational center to robot edges, makes placeholder rectangle\n    left: \"\",\n    right: \"\",\n    back: \"\",\n    front: \"\",\n  });\n  const [currentHeading, setCurrentHeading] = useState(0); // array for point headings\n  const [currentDirection, setCurrentDirection] = useState(1); // \"fwd\" or \"rev\" for forward or reverse direction\n  const [selectedPointIndex, setSelectedPointIndex] = useState(null);\n  //refs to track dragging state\n  const draggingPointIndex = useRef(null);\n  const isDragging = useRef(false); //currently dragging a point\n  const wasDragging = useRef(false); //when wasDragging is true, it means a user was dragging a point, so the next click should not add a point\n\n  //constants for field size and scale\n  const fieldSizeInches = 144;\n  const fieldImagePixels = 600;\n  const scale = fieldSizeInches / fieldImagePixels;\n\n  //used to prevent double clicks from adding points instead of deleting\n  const clickTimeout = useRef(null);\n\n  // updates offsets on input change\n  const handleOffsetChange = (e) => {\n    const { name, value } = e.target; //gets label (left, right, back, front) and value from input\n    setOffsets((prev) => ({\n      ...prev, //copies previous offsets\n      [name]: value === \"\" ? \"\" : parseFloat(value),\n      //the name becomes the key\n      //if the input is empty, set to empty string\n      //otherwise parse the value to a float\n    }));\n  };\n\n  //if the user clicks on a point, start dragging it\n  //handleMouseDown = click on an already existing point\n  const handleMouseDown = (index) => {\n    draggingPointIndex.current = index; //index = index of point clicked from points array\n    isDragging.current = true;\n    wasDragging.current = false;\n  };\n\n  //when user moves a point\n  const handleMouseMove = (e) => {\n    if (!isDragging.current || draggingPointIndex.current === null) return;\n    //if not currently dragging or no point has been dragged, ignore\n    wasDragging.current = true;\n    //else set wasDragging to true so next click does not add a point\n\n    const container = e.currentTarget; //e.currentTarget is the point currently being dragged\n    const rect = container.getBoundingClientRect(); //info about the container's pos and size\n\n    let rawX = e.clientX - rect.left; //how far the mouse is from the left edge of the image\n    let rawY = e.clientY - rect.top; //how far the mouse is from the top edge of the image\n\n    //clamp rawX and rawY to be within the image bounds\n    rawX = Math.max(0, Math.min(rawX, rect.width));\n    rawY = Math.max(0, Math.min(rawY, rect.height));\n\n    //sets center of the field as (0, 0), converts from pixels to inches\n    const dx = (rawX - rect.width / 2) * scale;\n    const dy = (rawY - rect.height / 2) * scale;\n\n    //checks that robot placeholder is fully inside field\n    const robotLeft = dx - offsets.left;\n    const robotRight = dx + offsets.right;\n    const robotBack = -dy - offsets.back;\n    const robotFront = -dy + offsets.front;\n    if (\n      robotLeft < -72 ||\n      robotRight > 72 ||\n      robotBack < -72 ||\n      robotFront > 72\n    ) {\n      //if its outside, ignore\n      return;\n    }\n\n    const updated = [...points]; //create a copy of points array to update\n    updated[draggingPointIndex.current] = {\n      //at the index of the point being dragged\n      ...updated[draggingPointIndex.current], //store existing properties\n      x: dx, //also stores coordinates in inches\n      y: -dy, //negative y because dy is distance from top, so it becomes more positive as you go down\n      //used for labeling on ui\n      rawX, //raw coords for displaying on field\n      rawY,\n    };\n    setPoints(updated);\n  };\n\n  // Mouse up - finish dragging\n  const handleMouseUp = () => {\n    draggingPointIndex.current = null;\n    setTimeout(() => {\n      isDragging.current = false;\n      wasDragging.current = false;\n    }, 10);\n  };\n\n  // Double click to delete point\n  const handleDoubleClick = (index) => {\n    if (clickTimeout.current) {\n      clearTimeout(clickTimeout.current);\n      clickTimeout.current = null;\n    }\n    setPoints(points.filter((_, i) => i !== index));\n  };\n\n  // Click on empty field to add a point (only if not dragging)\n  const handleClick = (e) => {\n    if (wasDragging.current) return;\n    if (clickTimeout.current) return;\n\n    const rect = e.currentTarget.getBoundingClientRect();\n    const rawX = e.clientX - rect.left;\n    const rawY = e.clientY - rect.top;\n\n    clickTimeout.current = setTimeout(() => {\n      clickTimeout.current = null;\n\n      // Out of bounds, ignore\n      if (rawX < 0 || rawY < 0 || rawX > rect.width || rawY > rect.height)\n        return;\n\n      const dx = (rawX - rect.width / 2) * scale;\n      const dy = (rawY - rect.height / 2) * scale;\n\n      // Check robot bounds with offsets\n      const robotLeft = dx - offsets.left;\n      const robotRight = dx + offsets.right;\n      const robotBack = -dy - offsets.back;\n      const robotFront = -dy + offsets.front;\n\n      if (\n        robotLeft < -72 ||\n        robotRight > 72 ||\n        robotBack < -72 ||\n        robotFront > 72\n      )\n        return;\n\n      setPoints([\n        ...points,\n        {\n          x: dx,\n          y: -dy,\n          rawX,\n          rawY,\n          heading: currentHeading,\n          direction: currentDirection,\n        },\n      ]);\n    }, 200);\n  };\n\n  // Heading input change\n  const handleHeadingChange = (e) => {\n    const newHeading = parseFloat(e.target.value) || 0;\n    setCurrentHeading(newHeading);\n\n    if (points.length > 0) {\n      const updated = [...points];\n      updated[points.length - 1] = {\n        ...updated[points.length - 1],\n        heading: newHeading,\n      };\n      setPoints(updated);\n    }\n  };\n\n  // Direction input change\n  const handleDirectionChange = (e) => {\n    const newDirection = e.target.value; // string \"fwd\" or \"rev\"\n    setCurrentDirection(newDirection);\n\n    if (points.length > 0) {\n      const updated = [...points];\n      updated[points.length - 1] = {\n        ...updated[points.length - 1],\n        direction: newDirection,\n      };\n      setPoints(updated);\n    }\n  };\n\n  return (\n    <div className=\"App\" style={{ userSelect: \"none\" }}>\n      <h1>vex auton tool</h1>\n      <Inputs\n        rotation={rotation}\n        setRotation={setRotation}\n        setPoints={setPoints}\n        offsets={offsets}\n        handleOffsetChange={handleOffsetChange}\n        currentHeading={currentHeading}\n        handleHeadingChange={handleHeadingChange}\n        currentDirection={currentDirection}\n        handleDirectionChange={handleDirectionChange}\n      />\n\n      <div\n        style={{\n          display: \"flex\",\n          alignItems: \"flex-start\",\n          gap: \"20px\",\n          maxWidth: \"1100px\",\n          margin: \"20px\",\n        }}\n      >\n        <Field\n          points={points}\n          setPoints={setPoints}\n          offsets={offsets}\n          rotation={rotation}\n          fieldImagePixels={fieldImagePixels}\n          scale={scale}\n          handleClick={handleClick}\n          handleMouseDown={handleMouseDown}\n          handleDoubleClick={handleDoubleClick}\n          handleMouseMove={handleMouseMove}\n          handleMouseUp={handleMouseUp}\n        />\n\n        <Subsystems />\n\n        <CodeOutput code={generateEZTemplateAuton(points)} />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}